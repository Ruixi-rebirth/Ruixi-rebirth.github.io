[{"content":"CREATE 创建数据库 数据库 被定义为一组结构化的数据,因此，在 SQL 中，以结构良好的方式存储数据的第一步是创建数据库。\n语法 1 CREATE DATABASE database_name; 示例 1 CREATE DATABASE StudentScore; 创建表 我们已经在上面了解了创建数据库。 现在要存储数据，我们需要一个表来执行此操作。 CREATE TABLE 语句用于在 SQL 中创建表。 我们知道一个表由行和列组成。 因此，在创建表时，我们必须向 SQL 提供有关列名、要存储在列中的数据类型、数据大小等所有信息。现在让我们深入了解如何使用 CREATE TABLE 语句创建 SQL 中的表。\n语法 1 2 3 4 5 6 7 CREATE TABLE table_name ( column1 data_type(size), column2 data_type(size), column3 data_type(size), .... ); 示例 1 1 2 3 4 5 6 CREATE TABLE Students ( Sno int(3), Sname varchar(20), Sage varchar(20), ); 示例 2 建立一个“学生”表 Student、它由学号 Sno、学生姓名 Sname、性别 Ssex、年龄 Sage、所在系 Sdept 组成，其中 Sno 为主码\n1 2 3 4 5 6 7 CREATE TABLE Student( Sno CHAR(9) PRIMARY KEY, Sname CHAR(20) UNIQUE, Ssex CHAR(2), Sage SMALLINT, Sdept CHAR(20) ); 示例 3 建立一个“课程”表 Course,它由课程号 Cno、课程名 Cname、先行课号 Cpno、学分 Ccredit 组成，其中 Cno 为主码\n1 2 3 4 5 6 7 CREATE TABLE Course( Cno CHAR(4) PRIMARY KEY, Cname CHAR(40), Cpno CHAR(4), Ccredit SMALLINT, FOREIGN KEY (Cpno) REFERENCES Course(Cno) ); 示例 4 建立一个“学生选课”表 Sc,它是由学号 Sno、课程号 Cno、选课成绩 Grade 组成，其中(Sno,Cno)为主码\n1 2 3 4 5 6 7 8 9 10 CREATE TABLE Sc( Sno CHAR(9), Cno CHAR(4), Grade SMALLINT, PRIMARY KEY (Sno,Cno), FOREIGN KEY (Sno) REFERENCES Student(Sno), FOREIGN KEY (Cno) REFERENCES Student(Cno) ); /*PRIMARY KEY 只能出现一次*/ 建立索引 语法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 CREATE [UNIQUE] [CLUMSTER] INDEX \u0026lt;索引名\u0026gt; ON \u0026lt;表名\u0026gt;(\u0026lt;列名\u0026gt;[\u0026lt;次序\u0026gt;][,\u0026lt;列名\u0026gt;[\u0026lt;次序\u0026gt;]]……); /*注意--\u0026gt; \u0026lt;次序\u0026gt;：DESC、ASC。缺省为升序ASC。 UNIQUE 表明此索引的每一个索引值只能对应唯一的数据记录（一对一） 对于含有重复值的属性列不能建立UNIQUE索引 对某个列建立UNIQUE索引后，插入新记录时DBMS会自动检查新记录在该列上是否取了重复值。这相当于增加了一个UNIQUE约束 CLUSTEM 表示建立的索引是聚簇索引 建立聚簇索引后，基本表中数据也需要按指定的聚簇属性值的升序或降序存放。即聚簇索引的索引项顺序与表中记录的物理顺序一致 在一个基本标上最多只能建立一个聚簇索引 聚簇索引用途：对于某些类型的查询，可以提高查询效率 聚簇索引适用范围：1.很少对基表增删改查 2.很少对其中的变长列进行修改操作*/ 示例 1 为学生-课程数据库中的 Course，Sc 表建立索引。其中 Course 表按课程号升序建立唯一索引，Sc 表按学号升序和课程号降序建唯一索引\n1 2 3 4 5 6 7 8 CREATE UNIQUE INDEX Coucno ON Course ( Cno ASC ); CREATE UNIQUE INDEX Scno ON Sc ( Cno ASC, Sno DESC ); 示例 2 为学生-课程数据库中的 Student 表的 Sname 列上建立一个聚簇索引，而且 Student 表中的记录按照 Sname 值的升序存放\n1 2 3 CREATE CLUSTERM INDEX Stusname ON Student ( Sname ASC ); DROP DROP 用于删除整个数据库或仅删除一个表。DROP 语句会破坏现有数据库、表、索引或视图等对象。\n语法 1 2 3 4 5 6 7 8 DROP object object_name Examples: DROP TABLE table_name; table_name: Name of the table to be deleted. DROP DATABASE database_name; database_name: Name of the database to be deleted. 例 1 删除 Student 表的 Stuname 索引\n1 DROP INDEX Stuname ON Student; ALTER ALTER TABLE 用于添加、删除/删除或修改现有表中的列。 它还用于在现有表上添加和删除各种约束\n更改表 - 添加 语法 1 2 3 4 5 6 7 ALTER TABLE table_name ADD ( Columnname_1 datatype, Columnname_2 datatype, … Columnname_n datatype ); 示例 1 向 Student 中增加“入学时间”列\n1 2 ALTER TABLE Student ADD S_entrance DATE; 示例 2 增加课程名称必须取唯一值的约束条件\n1 2 ATLER TABLE Course ADD UNIQUE (Cname); 更改表 - 删除 语法 DROP COLUMN 用于删除表中的列\n1 2 ALTER TABLE table_name DROP COLUMN column_name; 示例 1 删除 Student 表中的 PRIMARY KEY(SqlServer)\n1 2 3 ALTER TABLE Student DROP CONSTRAINT Student_PK; /*Student_PK 是主键的名称，如果创建主键时没有指定名称，就会随机设置一个名称*/ 改变表 - 修改 它用于修改表中的现有列\n语法 Syntax(SQL Server):\n1 2 ALTER TABLE table_name ALTER COLUMN column_name column_type; 示例 1 将 Student 表中的年龄的数据类型由字符型改为整数\n1 2 ALTER TABLE Student ALTER COLUMN Sage INT, TRUNCATE truncate 的作用是清空表或者说是截断表，只能作用于表;会清空表中的所有行，但表结构及其约束、索引等保持不变(empty for reuse)\n语法 1 2 TRUNCATE TABLE table_name; table_name: Name of the table to be truncated. DELETE SQL 中的 DELETE 语句用于从表中删除现有记录。 根据我们在 WHERE 子句中指定的条件，我们可以删除单个记录或多个记录。\n基本语法 1 2 3 4 DELETE FROM table_name WHERE some_condition; table_name: name of the table some_condition: condition to choose particular record. 示例 1 DELETE FROM Student WHERE NAME = \u0026#39;Ram\u0026#39;; Output:\nSno Sname Saddress Sphone Sage 2 Rash Aaa xxxxxx 18 3 Stuff Bbb xxxxxx 20 4 Sbt Ccc xxxxxx 18 5 Chen Ddd xxxxxx 20 6 Fres Eee xxxxxx 18 1 DELETE FROM Student WHERE Age = 20; Output:\nSno Sname Saddress Sphone Sage 1 Ram Delhi xxxxxx 18 2 Rash Aaa xxxxxx 18 4 Sbt Ccc xxxxxx 18 6 Fres Eee xxxxxx 18 删除所有记录？\n1 DELETE FROM Student; ","date":"2022-04-18T17:55:28+08:00","image":"https://ruixi.me/p/mssql02_1/feature_huf7af83464e498f6c07deb28ca12e88c7_93630_120x120_fill_q75_box_smart1.jpg","permalink":"https://ruixi.me/p/mssql02_1/","title":"Mssql02_1"},{"content":"\n众所周知，结构化查询语言（SQL）是一种数据库语言，通过它我们可以对现有的数据库执行某些操作，也可以使用这种语言来创建数据库。 SQL 使用某些命令（如 Create、Drop、Insert 等）来执行所需的任务。 这些 SQL 命令主要分为四类：\nDDL – 数据定义语言 DQL – 数据查询语言 DML – 数据操作语言 DCL – 数据控制语言 尽管许多资源声称存在另一类 SQL 子句 TCL – 事务控制语言 。 因此，我们还将详细了解 TCL。 DDL（数据定义语言） DDL 或数据定义语言实际上由可用于定义数据库模式的 SQL 命令组成。 它只处理数据库模式的描述，并用于创建和修改数据库中的数据库对象的结构。DDL 是一组用于创建、修改和删除数据库结构而不是数据的 SQL 命令。 这些命令通常不被一般用户使用，他们应该通过应用程序访问数据库\nDDL 命令列表：\nCREATE ：此命令用于创建数据库或其对象（如表、索引、函数、视图、存储过程和触发器）。 DROP ：此命令用于从数据库中删除对象。 ALTER ： 这用于更改数据库的结构。 TRUNCATE ： 这用于从表中删除所有记录，包括删除为记录分配的所有空间。 COMMENT ：用于向数据字典添加注释。 RENAME ： 这用于重命名数据库中存在的对象。 操作对象 操作方式/创建 操作方式/删除 操作方式/修改 数据库 CREATE DATABASE DROP DATABASE 表 CREATE TABLE DROP TABLE ALTER TABLE 视图 CREATE VIEW DROP VIEW 索引 CREATE INDEX DROP INDEX DQL（数据查询语言） DQL 语句用于对模式对象中的数据执行查询。 DQL 命令的目的是根据传递给它的查询获取一些模式关系。 我们可以将 DQL 定义如下，它是 SQL 语句的一个组件，允许从数据库中获取数据并对其进行排序。 它包括 SELECT 语句。 此命令允许从数据库中获取数据以对其执行操作。 当对一个或多个表触发 SELECT 时，结果会编译到另一个临时表中，该表会显示或可能由程序（即前端）接收。\nDQL 列表:\nSELECT ： 用于从数据库中检索数据。 DML（数据操作语言） 处理数据库中存在的数据操作的 SQL 命令属于 DML 或数据操作语言，这包括大多数 SQL 语句。 它是控制对数据和数据库的访问的 SQL 语句的组件。 基本上，DCL 语句与 DML 语句组合在一起。\nDML 命令列表：\nINSERT ：用于向表中插入数据。 UPDATE ： 它用于更新表中的现有数据。 DELETE ：用于从数据库表中删除记录。 LOCK： 表控制并发。 CALL： 调用 PL/SQL 或 JAVA 子程序。 EXPLAIN PLAN： 描述数据的访问路径。 DCL（数据控制语言） DCL 包括 GRANT、REVOKE 等命令，主要处理数据库系统的权限、权限等控制。\nDCL 命令列表：\nGRANT： 此命令授予用户访问数据库的权限。 REVOKE： 此命令撤销用户使用 GRANT 命令赋予的访问权限。 TCL（事务控制语言） TCL 命令列表：\nCOMMIT ： 提交事务。 ROLLBACK ： 在发生任何错误的情况下回滚事务。 SAVEPOINT ： 在事务中设置保存点。 SET TRANSACTION： 指定交易的特征。 MISC 支持 SQL 的 RDBMS 同样支持关系数据库三级模式\n基本表 本身独立存放的表（模式），在 SQL 中一个关系对应一个基本表。基本表和索引对应存储文件（内模式）\n视图 从一个或者几个基本表导出的表（外模式），是虚表，数据库中只是存放视图的定义而不存放视图对应的数据\n建立与删除索引 索引的作用：加快查询速度 谁来建立索引：\nDBA 或表的属主 有些 DBMS 自动建立以下列上的索引：PRIMARY KEY,UNIQUE 谁来维护索引：DBMS 自动完成 如何引用索引：DBMS 自动选择是否使用索引以及使用哪些索引 ","date":"2022-04-18T17:35:01+08:00","image":"https://ruixi.me/p/mssql02/feature_hu5438825b9b6d1014226d20d231e650c2_145826_120x120_fill_q75_box_smart1.jpg","permalink":"https://ruixi.me/p/mssql02/","title":"Mssql02"},{"content":"数据 1 描述事物的符号记录 数据库 1 长期存储在计算机内、有组织的、可共享的大量数据的集合 DBMS(Database Manager System) 1 数据库管理软件。如mysql,sqlserver,mariadb,Access等等内部都内置了各种的DBMS,所以也称这些都是DBMS,换言之，目前流行的DBMS有mysql,sqlserver等等 DBS 1 数据库系统也简称为数据库。由数据库，DBMS及其开发工具、应用程序(如学生管理系统的前台界面)、DBA及其用户构成 数据模型 1 2 (1)概念模型：按照用户的观点来对数据和信息建模（很重要，会影响到逻辑模型和物理模型） (2)逻辑模型和物理模型：主要包括网状模型、层次模型、关系模型等，它是按照计算机系统的观点对数据建模。用于DBMS的实现 数据模型的组成要素 1 2 3 1.数据结构 2.数据操作 3.数据的约束条件 实体 1 如一个学生、老师与院系的工作关系等 属性 1 如学生实体中的姓名、学号等 码 1 唯一标识实体的属性集。如学生实体的学号 域 1 属性的取值范围。如性别域（男、女） 实体型 1 实体名及其属性名集合来抽象刻画同类实体。如学生(姓名 学号 班级)就是一个实体型 实体集 1 如全体学生 概念模型标识方法 1 E-R 方法 即实体-联系方法 数据库系统的三级模式 1 模式(逻辑模式)是全体数据，外模式(子模式)是全体数据中的某一部分，内模式也称存储模式 外模式/模式映像 1 2 3 定义了外模式与模式之间的对应关系 每个外模式都对应一个外模式/模式映像（映像数量多个） 映像定义通常包含在各自外模式的描述中 模式/内模式映像 1 2 3 定义了数据全局逻辑结构与存储结构之间的对应关系 数据库中模式/内模式映像是唯一的 该映像的定义通常包含在模式描述中 关系数据模型 其数据结构是一张二维的表格\n候选码 1 能够被选为主码的属性或属性组，说明主码不唯一 主属性 定义：包含在任何候选码中的属性(主码一定是候选码，候选码不一定是主码，因为主码是人选的，是随机的) 例：比如，竞赛表（竞赛编号，竞赛名称，竞赛组织者） PS：竞赛名称和竞赛组织者都可以重复\n很明显可以看出竞赛编号能够唯一标识整张竞赛表，因此候选码是竞赛编号，并且仅此一个候选码，其他属性都不能唯一标识整张表，所竞赛编号同时也是主码。\n这时候判断一下这几个属性 or 属性组是否是主属性，（竞赛编号）（竞赛编号，竞赛名称）（竞赛名称，竞赛组织者），（竞赛编号）只有一个属性，这个属性是主码，主码必定为候选码，因此属性含有一个候选码，这个属性是主属性。（竞赛编号，竞赛名称）有两个属性，其中竞赛编号是候选码，而竞赛名称不是候选码，那他是啥呢~前面有提到了，因为它跟候选码在同一个属性组里，所以，竞赛名称是超码，回过头来，最后得出该属性组含有了一个候选码，因此该属性组中的各个属性都是主属性。（竞赛名称，竞赛组织者）有两个属性，可以看出这两个属性都不是候选码，因此这个属性组不包含候选码，属性组中中得各个元素称为非主属性。\nmisc 1 主码=主键=主关键字，关键字=候选码 候选关键字=候选码中除去主码的其他候选码 分量 1 如在二位表格中的单元格的值。关系的分量必须是一个不可分的数据项(如工资被分为奖金、工龄、基本，这样对于关系来说是不规范的) 元组 1 表中的每行（即数据库中的每条记录）就是一个元组;元组的个数为基数 目（度） 1 属性个数，也即列数 关系模型中的三类完整性约束 1 2 3 1. 实体完整性 2. 参照完整性 3. 用户定义完整性 实体完整性 1 实体完整性规则规定基本关系的所有主属性不能取空值，当我给某个表设置主键时，由于给主属性设置了空值，始终创建不了主码 参照完整性 1 在关系模型中实体与实体之间的联系都是用关系来描述的，因此存在关系与关系之间的引用 外码 设F是基本关系R中的一个或一组属性，但不是关系R的码。如果F与基本关系S中的主码K相对应，那么F是基本关系R的外码（外码取值可取空值，因为不是主属性;外码可取S中某个元组的主码值） 参照关系 外码所在的关系，即关系R为参照关系 被参照关系(目标关系) 关系S为参照关系\n例 1\n外码：专业 参照关系:学生关系 被参照关系：专业关系\n例 2\n外码：学号、课程号 参照关系:选修 被参照关系：学生关系、课程关系\n例 3\n外码：班长 参照关系:学生关系 被参照关系：学生关系\n用户定义完整性 1 2 3 4 例：课程(课程号，课程名，学分) 主码为课程号 - “课程名”属性必须取唯一值 - 非主属性“课程名”不能取空值 - “学分”属性只能取值{1,2,3,4} 关系代数运算的分类 1 2 1.传统的集合运算：并、交、差、广义笛卡尔积 2.专门的关系运算：选择、投影、连接、除 运算符及其对应关系 运算符 含义 ∪ 并 - 差 ∩ 交 × 笛卡尔积 σ 选择 π 投影 ⋈ 连接 ÷ 除 专门的关系运算 1 选择、投影、连接、除 记号 R, t∈ R, t[Ai]\n设关系模式为 R(A1,A2,……,An) t∈ R 表示 t 是 R 的一个元组 t[Ai]表示元组 t 中对应属性 Ai的一个分量(单元格的值) A, t[A], $\\overline{A}$ 若 A={Ai1,Ai2,……,Aik}\n其中 A 称为属性列或者域列 t[A]=([t[Ai1],t[Ai2],……,t[Aik])表示元组 t 在属性列 A 上诸分量的集合 $\\overline{A}$表示{A1,A2,……,An}中去掉{Ai1,Ai2,……,Aik}后剩余的属性列 象集\n选择 Sno Sname Ssex Sage Sdept 201215122 刘晨 女 19 IS 201215125 张立 男 19 IS 201215122 王敏 女 19 MA 201215122 李勇 男 19 CS 201215122 大地 男 20 IS 例 1 查询信息系（IS）全体学生的信息\n$$\\sigma_{Sdept=\u0026lsquo;IS\u0026rsquo;}(Student)$$ (字符串使用单引号)\nSno Sname Ssex Sage Sdept 201215122 刘晨 女 19 IS 201215125 张立 男 19 IS 201215122 大地 男 20 IS 例 2 查询信息系年龄小于 20的学生信息\n$$\\sigma_{Sdept=\u0026lsquo;IS\u0026rsquo;\\wedge Sage\u0026lt;20}(Student)$$\nSno Sname Ssex Sage Sdept 201215122 刘晨 女 19 IS 201215125 张立 男 19 IS 投影 投影后不仅取消了原关系中的某些列，而且还可能取消某些元组(避免重复行)\n例 3 求 Student 关系学生姓名和所在系两个属性上的投影：\n$$\\pi_{Sname,Sdept}(Student)$$\nSname Sdept 刘晨 IS 张立 IS 王敏 MA 李勇 CS 大地 IS 例 4 查询学生关系 Student 中都有哪些系？(涉及去重)\n$$\\pi_{Sdept}(Student)$$\nSdept MA CS IS 思考：查询信息系年龄\u0026lt;20 岁的学生学号、姓名、年龄？\n$$\\pi_{Sno,Sname,Sage}(\\sigma_{Sdept=‘IS’\\wedge Sage\u0026lt;20}(Student))$$\n连接(join) 1.普通连接\n关系 R\nA B C a1 b1 5 a1 b2 6 a2 b3 8 a2 b4 12 关系 S\nB E b1 3 b2 7 b3 10 b3 2 b5 2 两关系做笛卡尔积后结果为\nA R.B C S.B E a1 b1 5 b1 3 a1 b1 5 b2 7 a1 b1 5 b3 10 a1 b1 5 b3 2 a1 b1 5 b5 2 a1 b2 6 b1 3 a1 b2 6 b2 7 a1 b2 6 b3 10 a1 b2 6 b3 2 a1 b2 6 b2 2 a2 b3 8 b1 3 a2 b3 8 b2 7 a2 b3 8 b3 10 a2 b3 8 b3 2 a2 b3 8 b5 2 a2 b4 12 b1 3 a2 b2 12 b2 7 a2 b2 12 b3 10 a2 b2 12 b3 2 a2 b2 12 b5 2 根据C\u0026lt;E,筛选后得\nA R.B C S.B E a1 b1 5 b2 7 a1 b1 5 b3 10 a1 b2 6 b2 7 a1 b2 6 b3 10 a2 b3 8 b3 10 2.等值连接\nA R.B C S.B E a1 b1 5 b1 3 a1 b2 6 b2 7 a1 b2 6 b2 2 a2 b3 8 b3 10 a2 b3 8 b3 2 a2 b2 12 b2 7 3.自然连接\n是一种特殊的等值连接\nA B C E a1 b1 5 3 a1 b2 6 7 a1 b2 6 2 a2 b3 8 10 a2 b3 8 2 a2 b2 12 7 自然连接与等值连接区别:\n等值连接中不要求相等属性值的属性名相同，而自然连接要求相等属性值的属性名必须相同，即两关系只有在同名属性才能进行自然连接。如上例 R 中的 C 列和 S 中的 E 列可进行等值连接，但因为属性名不同，不能进行自然连接。 等值连接不将重复属性去掉，而自然连接去掉重复属性，也可以说，自然连接是去掉重复列的等值连接。如上例 R 中的 B 列和 S 中的 B 列进行等值连接时，结果有两个重复的属性列 B,而进行自然连接时，结果只有一个属性列 B 选择、投影、(自然)连接综合例题 $$\\pi_{sno,sname}(\\sigma_{cno=‘2’}(student\\bowtie sc))$$\n除 课后习题 ","date":"2022-04-16T12:56:25+08:00","image":"https://ruixi.me/p/mssql01/feature_hucb9f1ad58584b994a74448b91eda6d5e_7923121_120x120_fill_q75_box_smart1.jpg","permalink":"https://ruixi.me/p/mssql01/","title":"Mssql01"},{"content":"我的报错截图:\n具体解决方案 很多人记录过怎么执行 go test 单个文件或者单个函数，但是要么对执行单文件用例存在函数或变量引用的场景避而不谈，要么提示调用了其它文件中的模块会报错。其实了解了 golang 命令程序的机制之后，这个问题就迎刃而解了。\n阅读目录 背景 根本原因 解决方法 总结 背景 很多人记录过怎么执行 go test 单个文件或者单个函数，但是要么对执行单文件用例存在函数或变量引用的场景避而不谈，要么提示调用了其它文件中的模块会报错。其实了解了 go test 命令的机制之后，这个问题就迎刃而解了。\n也是一个同事向我求助我才知道有这样一个问题存在，因为场景特殊他只想执行我们的测试代码其中一个文件中的测试代码，因为调用的信息都在同一目录（package）下，原代码执行是不存在引用问题的，直接执行go test也是可以运行的，但是单独运行其中一个文件时，出现了下面的错误：\nbingo@Mac Interface_test$ go test -v getinfo_test.go # command-line-arguments ./getinfo_test.go:34:23: undefined: touch ./getinfo_test.go:35:23: undefined: verify ... FAIL\tcommand-line-arguments [build failed] 这也许是很多数人会遇到的一个错误，搜索引擎上没有找到相关的信息，有的人做了相关的记录来提示后来人：执行单文件存在引用时会报错。\n这可能也是使用 golang 做测试的弊端，因为发展时间不长，没有像 Python 或者 Java 那样成熟的社区；废话不多说，我们一起来看看这个问题为什么会发生。\n根本原因 其实从看看上面的这段提示：build failed，构建失败，我们应该就能看出一下信息。go test 与其他的指定源码文件进行编译或运行的命令程序一样（参考：go run和go build），会为指定的源码文件生成一个虚拟代码包——“command-line-arguments”，对于运行这次测试的命令程序来说，测试源码文件getinfo_test.go是属于代码包“command-line-arguments”的，可是它引用了其他包中的数据并不属于代码包“command-line-arguments”，编译不通过，错误自然发生了。\n解决方法 解决 知道了原因之后，解决的方法就出来了，执行命令时加入这个测试文件需要引用的源码文件，在命令行后方的文件都会被加载到command-line-arguments中进行编译。。示例如下：\nbingo@Mac Interface_test$ go test -v getinfo_test.go lib.go ok command-line-arguments 0.008s 多级引用或多个引用包的情况 如果对多个包存在引用关系，或者引用的包对当前目录的其他文件存在引用，也都是一样的方法，把他们加在命令后方即可。\n总结 测试单个文件，一定要带上被测试的原文件，如果原文件有其他引用，也需一并带上。\n(文章转载自https://www.cnblogs.com/Detector/p/10010292.html)\n","date":"2021-11-28T17:09:23+08:00","image":"https://ruixi.me/p/%E8%A7%A3%E5%86%B3go-test%E5%AF%B9%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8F%90%E7%A4%BAundefiend/feature_hu2380352a01ca5c017179876c09db13ea_149129_120x120_fill_box_smart1_3.png","permalink":"https://ruixi.me/p/%E8%A7%A3%E5%86%B3go-test%E5%AF%B9%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8F%90%E7%A4%BAundefiend/","title":"解决go test对单个文件进行单元测试提示undefiend"},{"content":"如果使用之前的GOPATH进行包管理的话会面临以下问题:\n在不使用额外的工具的情况下，Go 的依赖包需要手工下载 第三方包没有版本的概念，如果第三方包的作者做了不兼容升级，会让开发者很难受 协作开发时，需要统一各个开发成员本地$GOPATH/src下的依赖包 引用的包引用了已经转移的包，而作者没改的话，需要自己修改引用 第三方包和自己的包的源码都在 src 下，很混乱。对于混合技术栈的项目来说，目录的存放会有一些问题 新的包管理模式go mod解决了以上问题:\n自动下载依赖包(有前提) 项目不必放在 GOPATH/src 内了 项目内会生成一个 go.mod 文件，列出包依赖 所有来的第三方包会准确的指定版本号 对于已经转移的包，可以用 replace 申明替换，不需要改代码 准备工作 1.golang 版本必须支持 go mod\n2.添加环境变量 GO111MODULE 为 on 或者auto\n创建一个项目 首先，在$GOPATH/src 路径外的你喜欢的地方创建一个目录，cd 进入目录，新建一个 hello.go 文件，内容如下\n1 2 3 4 5 6 7 package main import ( \u0026#34;fmt\u0026#34; ) func main() { fmt.Println(\u0026#34;Hello, world!\u0026#34;) } 初始化模块 在当前目录下，命令行运行 go mod init + 模块名称 初始化模块\n1 go mod init hello 运行完后，会在当前项目目录下生成一个 go.mod 文件，这是一个关键文件，之后的包的管理都是通过这个文件管理。\n官方说明：除了 go.mod 之外，go 命令还维护一个名为 go.sum 的文件，其中包含特定模块版本内容的预期加密哈希\ngo 命令使用 go.sum 文件确保这些模块的未来下载检索与第一次下载相同的位，以确保项目所依赖的模块不会出现意外更改，无论是出于恶意、意外还是其他原因。 go.mod 和 go.sum 都应检入版本控制。\ngo.sum 不需要手工维护，所以可以不用太关注。\n生成出来的文件包含模块名称和当前的 go 版本号\n1 2 module hello go 1.17 注意：子目录里是不需要 init 的，所有的子目录里的依赖都会组织在根目录的 go.mod 文件里\n看看 go mod 如何工作的 接下来，让项目依赖一下第三方包以大部分人都熟悉的 beego 为例吧！修改 Hello.go 文件：\n1 2 3 4 5 package main import \u0026#34;github.com/astaxie/beego\u0026#34; func main() { beego.Run() } 接下来执行 go run hello.go 然后会提示叫用 go get 下载引用第三方包，那就用呗。\n下载完第三方包后，再次 go run hello.go 就跑起来啦！\n问题：依赖的包下载到哪里了？ 使用 Go 的包管理方式，依赖的第三方包被下载到了$GOPATH/pkg/mod 路径下。（可以自行更改下载路径）\n","date":"2021-11-28T16:24:57+08:00","image":"https://ruixi.me/p/%E6%B5%85%E8%B0%88gomod/feature_hub77d8aefc3f93e91b3b5a5aca129e83e_217071_120x120_fill_box_smart1_3.png","permalink":"https://ruixi.me/p/%E6%B5%85%E8%B0%88gomod/","title":"浅谈GoMod"},{"content":"关于“回车”（carriage return）和“换行”（line feed）这两个概念的来历和区别 关于换行和回车其实平时我们不太在意，所以关于两者的区别也不太清楚，在平时开发时可能会遇到一些文件处理的问题，放到不同的操作系统上出现各种坑。那么回车和换行到底有哪些区别呢？今天咱们就来总结一下。\n1. 由来 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的机械打字机，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。\n于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界，不卷动滚筒；另一个叫做“换行”，告诉打字机把滚筒卷一格，不改变水平位置。\n这就是“换行”和“回车”的由来。\n2. 使用 后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。\n回车 \\r 本义是光标重新回到本行开头，r的英文return，控制字符可以写成CR，即Carriage Return\n换行 \\n 本义是光标往下一行（不一定到下一行行首），n的英文newline，控制字符可以写成LF，即Line Feed\n符号 ASCII码 意义\n\\n 10 换行NL\n\\r 13 回车CR\n在不同的操作系统这几个字符表现不同，比如在WIN系统下，这两个字符就是表现的本义，在UNIX类系统，换行\\n就表现为光标下一行并回到行首，在MAC上，\\r就表现为回到本行开头并往下一行，至于ENTER键的定义是与操作系统有关的。通常用的Enter是两个加起来。\n不同操作系统下的含义：\n\\n: UNIX 系统行末结束符\n\\n\\r: window 系统行末结束符\n\\r: MAC OS 系统行末结束符\n我们经常遇到的一个问题就是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。\n3. 软回车和硬回车 再扩展一下回车的一些知识。\n硬回车就是普通我们按回车产生的，它在换行的同时也起着段落分隔的作用。 软回车是用 Shift + Enter 产生的，它换行，但是并不换段，即前后两段文字在 Word 中属于同一“段”。在应用格式时你会体会到这一点。\n软回车能使前后两行的行间距大幅度缩小，因为它不是段落标记，要和法定的段落标记——硬回车区别出来。硬回车的html代码是\u0026lt;p\u0026gt;..\u0026lt;/p\u0026gt;，段落的内容就夹在里面，而软回车的代码很精悍：\u0026lt;br\u0026gt;。网页的文字如果复制到word中，则硬回车变为弯曲的箭头，软回车变为向下的箭头。\n转载在自:https://www.pythontab.com/html/2017/linuxkaiyuan_0115/1116.html\n","date":"2021-11-28T16:12:56+08:00","image":"https://ruixi.me/p/%E5%9B%9E%E8%BD%A6-%E6%8D%A2%E8%A1%8C/feature_hu8b727be42d0f187c562c1e706f400774_3656812_120x120_fill_box_smart1_3.png","permalink":"https://ruixi.me/p/%E5%9B%9E%E8%BD%A6-%E6%8D%A2%E8%A1%8C/","title":"回车 \u0026 换行"},{"content":"\r","date":"2021-11-27T21:49:15+08:00","image":"https://ruixi.me/p/animate_2021%E5%91%86%E5%94%AF%E7%94%9F%E6%97%A5%E7%A5%AD%E8%AF%B4%E4%B8%8D%E5%AE%8C%E7%9A%84%E7%9C%81%E7%95%A5%E5%8F%B7/feature_hu22c8daf3883fd66ce5c579603f3c4959_950319_120x120_fill_q75_box_smart1.jpg","permalink":"https://ruixi.me/p/animate_2021%E5%91%86%E5%94%AF%E7%94%9F%E6%97%A5%E7%A5%AD%E8%AF%B4%E4%B8%8D%E5%AE%8C%E7%9A%84%E7%9C%81%E7%95%A5%E5%8F%B7/","title":"Animate_2021呆唯生日祭——说不完的省略号"},{"content":"在实际操作之前，我们需要知道 go 有三种源码文件：\n1，命令源码文件；声明自己属于 main 包，并且包含 main 函数的文件，每个项目只能有一个这样的文件，即程序的入口文件\n2，库源码文件；不能直接被执行的源码文件\n3，测试源码文件\ngo run : 编译并直接运行程序，不产生可执行文件，只产生临时文件，方便用户调试（即在 bin 目录和 pkg 目录不产生任何文件）,其后只能+命令源码文件。\ngo build : 既可以+库源码文件，又可以+命令源码文件,主要功能是检查是否有编译错误\n+库源码文件：只是检查编译错误，不产生任何文件,如果库源码文件有语法错误，编译不通过会报错。\n+命令源码文件：产生一个可执行文件\ngo install : 执行的过程：编译库源码文件-\u0026gt;编译命令源码文件-\u0026gt;移动编译文件，命令源码文件的编译后的二进制文件移到$GOPATH/bin目录下；库源码文件的编译移到$GOPATH/pkg 目录,后缀名为.a 的文件。这个移动目录的过程称为安装。\nPs：上述的二进制可执行文件可独立运行，当然可以放在任何目录下运行啦\n","date":"2021-11-26T07:47:36+08:00","image":"https://ruixi.me/p/go-run-go-build-go-install/go_hu73bdf5a8973a4e92e78daf1a9a1f2819_21124_120x120_fill_q75_box_smart1.jpg","permalink":"https://ruixi.me/p/go-run-go-build-go-install/","title":"Go Run ,Go Build , Go Install"},{"content":" ","date":"2021-11-25T16:02:33+08:00","image":"https://ruixi.me/p/video/gujian_hu1bb1dd2bfff1b68df907e3e860b98d69_75532_120x120_fill_q75_box_smart1.jpg","permalink":"https://ruixi.me/p/video/","title":"Video"}]