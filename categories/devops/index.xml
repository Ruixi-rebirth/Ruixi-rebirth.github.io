<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Devops on ruixi-Let's Go!</title><link>https://ruixi.me/categories/devops/</link><description>Recent content in Devops on ruixi-Let's Go!</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 18 Apr 2022 17:55:28 +0800</lastBuildDate><atom:link href="https://ruixi.me/categories/devops/index.xml" rel="self" type="application/rss+xml"/><item><title>Mssql02_1</title><link>https://ruixi.me/p/mssql02_1/</link><pubDate>Mon, 18 Apr 2022 17:55:28 +0800</pubDate><guid>https://ruixi.me/p/mssql02_1/</guid><description>CREATE SQL 中有两个可用的 CREATE 语句
创建数据库 创建表 创建数据库 数据库 被定义为一组结构化的数据,因此，在 SQL 中，以结构良好的方式存储数据的第一步是创建数据库。
语法 CREATEDATABASEdatabase_name;示例 CREATEDATABASEStudentScore;创建表 我们已经在上面了解了创建数据库。 现在要存储数据，我们需要一个表来执行此操作。 CREATE TABLE 语句用于在 SQL 中创建表。 我们知道一个表由行和列组成。 因此，在创建表时，我们必须向 SQL 提供有关列名、要存储在列中的数据类型、数据大小等所有信息。现在让我们深入了解如何使用 CREATE TABLE 语句创建 SQL 中的表。
语法 CREATETABLEtable_name(column1data_type(size),column2data_type(size),column3data_type(size),....);示例 CREATETABLEStudents(Snoint(3),Snamevarchar(20),Sagevarchar(20),);DROP DROP 用于删除整个数据库或仅删除一个表。DROP 语句会破坏现有数据库、表、索引或视图等对象。
语法 DROPobjectobject_nameExamples:DROPTABLEtable_name;table_name:Nameofthetabletobedeleted.DROPDATABASEdatabase_name;database_name:Nameofthedatabasetobedeleted.ALTER ALTER TABLE 用于添加、删除/删除或修改现有表中的列。 它还用于在现有表上添加和删除各种约束
更改表 - 添加 ADD 用于将列添加到现有表中。 有时我们可能需要添加额外的信息，在这种情况下我们不需要再次创建整个数据库， ADD 来拯救我们
语法 ALTERTABLEtable_nameADD(Columnname_1datatype,Columnname_2datatype,…Columnname_ndatatype);更改表 - 删除 语法 DROP COLUMN 用于删除表中的列
ALTERTABLEtable_nameDROPCOLUMNcolumn_name;改变表 - 修改 它用于修改表中的现有列
语法 Syntax(Oracle,MySQL,MariaDB):
ALTERTABLEtable_nameMODIFYcolumn_namecolumn_type;Syntax(SQL Server):
ALTERTABLEtable_nameALTERCOLUMNcolumn_namecolumn_type;TRUNCATE truncate 的作用是清空表或者说是截断表，只能作用于表;会清空表中的所有行，但表结构及其约束、索引等保持不变(empty for reuse)</description></item><item><title>Mssql02</title><link>https://ruixi.me/p/mssql02/</link><pubDate>Mon, 18 Apr 2022 17:35:01 +0800</pubDate><guid>https://ruixi.me/p/mssql02/</guid><description>众所周知，结构化查询语言（SQL）是一种数据库语言，通过它我们可以对现有的数据库执行某些操作，也可以使用这种语言来创建数据库。 SQL 使用某些命令（如 Create、Drop、Insert 等）来执行所需的任务。 这些 SQL 命令主要分为四类：
DDL – 数据定义语言 DQL – 数据查询语言 DML – 数据操作语言 DCL – 数据控制语言 尽管许多资源声称存在另一类 SQL 子句 TCL – 事务控制语言 。 因此，我们还将详细了解 TCL。 DDL（数据定义语言） DDL 或数据定义语言实际上由可用于定义数据库模式的 SQL 命令组成。 它只处理数据库模式的描述，并用于创建和修改数据库中的数据库对象的结构。DDL 是一组用于创建、修改和删除数据库结构而不是数据的 SQL 命令。 这些命令通常不被一般用户使用，他们应该通过应用程序访问数据库
DDL 命令列表：
CREATE ：此命令用于创建数据库或其对象（如表、索引、函数、视图、存储过程和触发器）。 DROP ：此命令用于从数据库中删除对象。 ALTER ： 这用于更改数据库的结构。 TRUNCATE ： 这用于从表中删除所有记录，包括删除为记录分配的所有空间。 COMMENT ：用于向数据字典添加注释。 RENAME ： 这用于重命名数据库中存在的对象。 DQL（数据查询语言） DQL 语句用于对模式对象中的数据执行查询。 DQL 命令的目的是根据传递给它的查询获取一些模式关系。 我们可以将 DQL 定义如下，它是 SQL 语句的一个组件，允许从数据库中获取数据并对其进行排序。 它包括 SELECT 语句。 此命令允许从数据库中获取数据以对其执行操作。 当对一个或多个表触发 SELECT 时，结果会编译到另一个临时表中，该表会显示或可能由程序（即前端）接收。</description></item><item><title>Mssql01</title><link>https://ruixi.me/p/mssql01/</link><pubDate>Sat, 16 Apr 2022 12:56:25 +0800</pubDate><guid>https://ruixi.me/p/mssql01/</guid><description>数据 描述事物的符号记录 数据库 长期存储在计算机内、有组织的、可共享的大量数据的集合 DBMS(Database Manager System) 数据库管理软件。如mysql,sqlserver,mariadb,Access等等内部都内置了各种的DBMS,所以也称这些都是DBMS,换言之，目前流行的DBMS有mysql,sqlserver等等 DBS 数据库系统也简称为数据库。由数据库，DBMS及其开发工具、应用程序(如学生管理系统的前台界面)、DBA及其用户构成 数据模型 (1)概念模型：按照用户的观点来对数据和信息建模（很重要，会影响到逻辑模型和物理模型） (2)逻辑模型和物理模型：主要包括网状模型、层次模型、关系模型等，它是按照计算机系统的观点对数据建模。用于DBMS的实现 数据模型的组成要素 1.数据结构 2.数据操作 3.数据的约束条件 实体 如一个学生、老师与院系的工作关系等 属性 如学生实体中的姓名、学号等 码 唯一标识实体的属性集。如学生实体的学号 域 属性的取值范围。如性别域（男、女） 实体型 实体名及其属性名集合来抽象刻画同类实体。如学生(姓名 学号 班级)就是一个实体型 实体集 如全体学生 概念模型标识方法 E-R 方法 即实体-联系方法 数据库系统的三级模式 模式(逻辑模式)是全体数据，外模式(子模式)是全体数据中的某一部分，内模式也称存储模式 外模式/模式映像 定义了外模式与模式之间的对应关系 每个外模式都对应一个外模式/模式映像（映像数量多个） 映像定义通常包含在各自外模式的描述中 模式/内模式映像 定义了数据全局逻辑结构与存储结构之间的对应关系 数据库中模式/内模式映像是唯一的 该映像的定义通常包含在模式描述中 关系数据模型 其数据结构是一张二维的表格
候选码 能够被选为主码的属性或属性组，说明主码不唯一 主属性 定义：包含在任何候选码中的属性(主码一定是候选码，候选码不一定是主码，因为主码是人选的，是随机的) 例：比如，竞赛表（竞赛编号，竞赛名称，竞赛组织者） PS：竞赛名称和竞赛组织者都可以重复
很明显可以看出竞赛编号能够唯一标识整张竞赛表，因此候选码是竞赛编号，并且仅此一个候选码，其他属性都不能唯一标识整张表，所竞赛编号同时也是主码。
这时候判断一下这几个属性 or 属性组是否是主属性，（竞赛编号）（竞赛编号，竞赛名称）（竞赛名称，竞赛组织者），（竞赛编号）只有一个属性，这个属性是主码，主码必定为候选码，因此属性含有一个候选码，这个属性是主属性。（竞赛编号，竞赛名称）有两个属性，其中竞赛编号是候选码，而竞赛名称不是候选码，那他是啥呢~前面有提到了，因为它跟候选码在同一个属性组里，所以，竞赛名称是超码，回过头来，最后得出该属性组含有了一个候选码，因此该属性组中的各个属性都是主属性。（竞赛名称，竞赛组织者）有两个属性，可以看出这两个属性都不是候选码，因此这个属性组不包含候选码，属性组中中得各个元素称为非主属性。
misc 主码=主键=主关键字，关键字=候选码 候选关键字=候选码中除去主码的其他候选码 分量 如在二位表格中的单元格的值。关系的分量必须是一个不可分的数据项(如工资被分为奖金、工龄、基本，这样对于关系来说是不规范的) 元组 表中的每行（即数据库中的每条记录）就是一个元组;元组的个数为基数 目（度） 属性个数，也即列数 关系模型中的三类完整性约束 1.</description></item><item><title>解决go test对单个文件进行单元测试提示undefiend</title><link>https://ruixi.me/p/%E8%A7%A3%E5%86%B3go-test%E5%AF%B9%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8F%90%E7%A4%BAundefiend/</link><pubDate>Sun, 28 Nov 2021 17:09:23 +0800</pubDate><guid>https://ruixi.me/p/%E8%A7%A3%E5%86%B3go-test%E5%AF%B9%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8F%90%E7%A4%BAundefiend/</guid><description>我的报错截图:
具体解决方案 很多人记录过怎么执行 go test 单个文件或者单个函数，但是要么对执行单文件用例存在函数或变量引用的场景避而不谈，要么提示调用了其它文件中的模块会报错。其实了解了 golang 命令程序的机制之后，这个问题就迎刃而解了。
阅读目录 背景 根本原因 解决方法 总结 背景 很多人记录过怎么执行 go test 单个文件或者单个函数，但是要么对执行单文件用例存在函数或变量引用的场景避而不谈，要么提示调用了其它文件中的模块会报错。其实了解了 go test 命令的机制之后，这个问题就迎刃而解了。
也是一个同事向我求助我才知道有这样一个问题存在，因为场景特殊他只想执行我们的测试代码其中一个文件中的测试代码，因为调用的信息都在同一目录（package）下，原代码执行是不存在引用问题的，直接执行go test也是可以运行的，但是单独运行其中一个文件时，出现了下面的错误：
bingo@Mac Interface_test$ go test -v getinfo_test.go # command-line-arguments ./getinfo_test.go:34:23: undefined: touch ./getinfo_test.go:35:23: undefined: verify ... FAIL command-line-arguments [build failed] 这也许是很多数人会遇到的一个错误，搜索引擎上没有找到相关的信息，有的人做了相关的记录来提示后来人：执行单文件存在引用时会报错。
这可能也是使用 golang 做测试的弊端，因为发展时间不长，没有像 Python 或者 Java 那样成熟的社区；废话不多说，我们一起来看看这个问题为什么会发生。
根本原因 其实从看看上面的这段提示：build failed，构建失败，我们应该就能看出一下信息。go test 与其他的指定源码文件进行编译或运行的命令程序一样（参考：go run和go build），会为指定的源码文件生成一个虚拟代码包——“command-line-arguments”，对于运行这次测试的命令程序来说，测试源码文件getinfo_test.go是属于代码包“command-line-arguments”的，可是它引用了其他包中的数据并不属于代码包“command-line-arguments”，编译不通过，错误自然发生了。
解决方法 解决 知道了原因之后，解决的方法就出来了，执行命令时加入这个测试文件需要引用的源码文件，在命令行后方的文件都会被加载到command-line-arguments中进行编译。。示例如下：
bingo@Mac Interface_test$ go test -v getinfo_test.go lib.go ok command-line-arguments 0.</description></item><item><title>浅谈GoMod</title><link>https://ruixi.me/p/%E6%B5%85%E8%B0%88gomod/</link><pubDate>Sun, 28 Nov 2021 16:24:57 +0800</pubDate><guid>https://ruixi.me/p/%E6%B5%85%E8%B0%88gomod/</guid><description>如果使用之前的GOPATH进行包管理的话会面临以下问题:
在不使用额外的工具的情况下，Go 的依赖包需要手工下载 第三方包没有版本的概念，如果第三方包的作者做了不兼容升级，会让开发者很难受 协作开发时，需要统一各个开发成员本地$GOPATH/src下的依赖包 引用的包引用了已经转移的包，而作者没改的话，需要自己修改引用 第三方包和自己的包的源码都在 src 下，很混乱。对于混合技术栈的项目来说，目录的存放会有一些问题 新的包管理模式go mod解决了以上问题:
自动下载依赖包(有前提) 项目不必放在 GOPATH/src 内了 项目内会生成一个 go.mod 文件，列出包依赖 所有来的第三方包会准确的指定版本号 对于已经转移的包，可以用 replace 申明替换，不需要改代码 准备工作 1.golang 版本必须支持 go mod
2.添加环境变量 GO111MODULE 为 on 或者auto
创建一个项目 首先，在$GOPATH/src 路径外的你喜欢的地方创建一个目录，cd 进入目录，新建一个 hello.go 文件，内容如下
package main import ( &amp;#34;fmt&amp;#34; ) func main() { fmt.Println(&amp;#34;Hello, world!&amp;#34;) } 初始化模块 在当前目录下，命令行运行 go mod init + 模块名称 初始化模块
go mod init hello 运行完后，会在当前项目目录下生成一个 go.mod 文件，这是一个关键文件，之后的包的管理都是通过这个文件管理。
官方说明：除了 go.</description></item><item><title>Go Run ,Go Build , Go Install</title><link>https://ruixi.me/p/go-run-go-build-go-install/</link><pubDate>Fri, 26 Nov 2021 07:47:36 +0800</pubDate><guid>https://ruixi.me/p/go-run-go-build-go-install/</guid><description>在实际操作之前，我们需要知道 go 有三种源码文件：
1，命令源码文件；声明自己属于 main 包，并且包含 main 函数的文件，每个项目只能有一个这样的文件，即程序的入口文件
2，库源码文件；不能直接被执行的源码文件
3，测试源码文件
go run : 编译并直接运行程序，不产生可执行文件，只产生临时文件，方便用户调试（即在 bin 目录和 pkg 目录不产生任何文件）,其后只能+命令源码文件。
go build : 既可以+库源码文件，又可以+命令源码文件,主要功能是检查是否有编译错误
+库源码文件：只是检查编译错误，不产生任何文件,如果库源码文件有语法错误，编译不通过会报错。
+命令源码文件：产生一个可执行文件
go install : 执行的过程：编译库源码文件-&amp;gt;编译命令源码文件-&amp;gt;移动编译文件，命令源码文件的编译后的二进制文件移到$GOPATH/bin目录下；库源码文件的编译移到$GOPATH/pkg 目录,后缀名为.a 的文件。这个移动目录的过程称为安装。
Ps：上述的二进制可执行文件可独立运行，当然可以放在任何目录下运行啦</description></item></channel></rss>