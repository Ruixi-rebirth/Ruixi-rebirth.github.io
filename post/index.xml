<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on ruixi-Let's Go!</title><link>https://ruixi.me/post/</link><description>Recent content in Posts on ruixi-Let's Go!</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 16 Apr 2022 12:56:38 +0800</lastBuildDate><atom:link href="https://ruixi.me/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Mssql05</title><link>https://ruixi.me/p/mssql05/</link><pubDate>Sat, 16 Apr 2022 12:56:38 +0800</pubDate><guid>https://ruixi.me/p/mssql05/</guid><description/></item><item><title>Mssql04</title><link>https://ruixi.me/p/mssql04/</link><pubDate>Sat, 16 Apr 2022 12:56:36 +0800</pubDate><guid>https://ruixi.me/p/mssql04/</guid><description>运算符 含义 ∪ 并 - 差 ∩ 交 × 笛卡尔积 σ 选择 π 投影 ⋈ 连接 ÷ 除 专门的关系运算 选择、投影、连接、除 记号 R, t∈ R, t[Ai]
设关系模式为 R(A1,A2,……,An) t∈ R 表示 t 是 R 的一个元组 t[Ai]表示元组 t 中对应属性 Ai的一个分量(单元格的值) A, t[A], $\overline{A}$ 若 A={Ai1,Ai2,……,Aik}</description></item><item><title>Mssql03</title><link>https://ruixi.me/p/mssql03/</link><pubDate>Sat, 16 Apr 2022 12:56:34 +0800</pubDate><guid>https://ruixi.me/p/mssql03/</guid><description>候选码 能够被选为主码的属性或属性组，说明主码不唯一 主属性 定义：包含在任何候选码中的属性(主码一定是候选码，候选码不一定是主码，因为主码是人选的，是随机的) 例：比如，竞赛表（竞赛编号，竞赛名称，竞赛组织者） PS：竞赛名称和竞赛组织者都可以重复
很明显可以看出竞赛编号能够唯一标识整张竞赛表，因此候选码是竞赛编号，并且仅此一个候选码，其他属性都不能唯一标识整张表，所竞赛编号同时也是主码。
这时候判断一下这几个属性 or 属性组是否是主属性，（竞赛编号）（竞赛编号，竞赛名称）（竞赛名称，竞赛组织者），（竞赛编号）只有一个属性，这个属性是主码，主码必定为候选码，因此属性含有一个候选码，这个属性是主属性。（竞赛编号，竞赛名称）有两个属性，其中竞赛编号是候选码，而竞赛名称不是候选码，那他是啥呢~前面有提到了，因为它跟候选码在同一个属性组里，所以，竞赛名称是超码，回过头来，最后得出该属性组含有了一个候选码，因此该属性组中的各个属性都是主属性。（竞赛名称，竞赛组织者）有两个属性，可以看出这两个属性都不是候选码，因此这个属性组不包含候选码，属性组中中得各个元素称为非主属性。
misc 主码=主键=主关键字，关键字=候选码 候选关键字=候选码中除去主码的其他候选码 元组 表中的每行（即数据库中的每条记录）就是一个元组;元组的个数为基数 目（度） 属性个数，也即列数 关系模型中的三类完整性约束 1. 实体完整性 2. 参照完整性 3. 用户定义完整性 实体完整性 实体完整性规则规定基本关系的所有主属性不能取空值，当我给某个表设置主键时，由于给主属性设置了空值，始终创建不了主码 参照完整性 在关系模型中实体与实体之间的联系都是用关系来描述的，因此存在关系与关系之间的引用 外码 设F是基本关系R中的一个或一组属性，但不是关系R的码。如果F与基本关系S中的主码K相对应，那么F是基本关系R的外码（外码取值可取空值，因为不是主属性;外码可取S中某个元组的主码值） 参照关系 外码所在的关系，即关系R为参照关系 被参照关系(目标关系) 关系S为参照关系
例 1
外码：专业 参照关系:学生关系 被参照关系：专业关系
例 2
外码：学号、课程号 参照关系:选修 被参照关系：学生关系、课程关系
例 3
外码：班长 参照关系:学生关系 被参照关系：学生关系
用户定义完整性 例：课程(课程号，课程名，学分) 主码为课程号 - “课程名”属性必须取唯一值 - 非主属性“课程名”不能取空值 - “学分”属性只能取值{1,2,3,4} 关系代数运算的分类 1.</description></item><item><title>Mssql02</title><link>https://ruixi.me/p/mssql02/</link><pubDate>Sat, 16 Apr 2022 12:56:30 +0800</pubDate><guid>https://ruixi.me/p/mssql02/</guid><description>###关系数据模型（其数据结构是一张二维的表格）
分量 如在二位表格中的单元格的值。关系的分量必须是一个不可分的数据项(如工资被分为奖金、工龄、基本，这样对于关系来说是不规范的) 数据库系统的三级模式 模式(逻辑模式)是全体数据，外模式(子模式)是全体数据中的某一部分，内模式也称存储模式 外模式/模式映像 定义了外模式与模式之间的对应关系 每个外模式都对应一个外模式/模式映像（映像数量多个） 映像定义通常包含在各自外模式的描述中 模式/内模式映像 定义了数据全局逻辑结构与存储结构之间的对应关系 数据库中模式/内模式映像是唯一的 该映像的定义通常包含在模式描述中</description></item><item><title>Mssql01</title><link>https://ruixi.me/p/mssql01/</link><pubDate>Sat, 16 Apr 2022 12:56:25 +0800</pubDate><guid>https://ruixi.me/p/mssql01/</guid><description>数据 描述事物的符号记录 数据库 长期存储在计算机内、有组织的、可共享的大量数据的集合 DBMS(Database Manager System) 数据库管理软件。如mysql,sqlserver,mariadb,Access等等内部都内置了各种的DBMS,所以也称这些都是DBMS,换言之，目前流行的DBMS有mysql,sqlserver等等 DBS 数据库系统也简称为数据库。由数据库，DBMS及其开发工具、应用程序(如学生管理系统的前台界面)、DBA及其用户构成 数据模型 (1)概念模型：按照用户的观点来对数据和信息建模（很重要，会影响到逻辑模型和物理模型） (2)逻辑模型和物理模型：主要包括网状模型、层次模型、关系模型等，它是按照计算机系统的观点对数据建模。用于DBMS的实现 数据模型的组成要素 1.数据结构 2.数据操作 3.数据的约束条件 实体 如一个学生、老师与院系的工作关系等 属性 如学生实体中的姓名、学号等 码 唯一标识实体的属性集。如学生实体的学号 域 属性的取值范围。如性别域（男、女） 实体型 实体名及其属性名集合来抽象刻画同类实体。如学生(姓名 学号 班级)就是一个实体型 实体集 如全体学生 概念模型标识方法 E-R 方法 即实体-联系方法</description></item><item><title>解决go test对单个文件进行单元测试提示undefiend</title><link>https://ruixi.me/p/%E8%A7%A3%E5%86%B3go-test%E5%AF%B9%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8F%90%E7%A4%BAundefiend/</link><pubDate>Sun, 28 Nov 2021 17:09:23 +0800</pubDate><guid>https://ruixi.me/p/%E8%A7%A3%E5%86%B3go-test%E5%AF%B9%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8F%90%E7%A4%BAundefiend/</guid><description>我的报错截图:
具体解决方案 很多人记录过怎么执行 go test 单个文件或者单个函数，但是要么对执行单文件用例存在函数或变量引用的场景避而不谈，要么提示调用了其它文件中的模块会报错。其实了解了 golang 命令程序的机制之后，这个问题就迎刃而解了。
阅读目录 背景 根本原因 解决方法 总结 背景 很多人记录过怎么执行 go test 单个文件或者单个函数，但是要么对执行单文件用例存在函数或变量引用的场景避而不谈，要么提示调用了其它文件中的模块会报错。其实了解了 go test 命令的机制之后，这个问题就迎刃而解了。
也是一个同事向我求助我才知道有这样一个问题存在，因为场景特殊他只想执行我们的测试代码其中一个文件中的测试代码，因为调用的信息都在同一目录（package）下，原代码执行是不存在引用问题的，直接执行go test也是可以运行的，但是单独运行其中一个文件时，出现了下面的错误：
bingo@Mac Interface_test$ go test -v getinfo_test.go # command-line-arguments ./getinfo_test.go:34:23: undefined: touch ./getinfo_test.go:35:23: undefined: verify ... FAIL command-line-arguments [build failed] 这也许是很多数人会遇到的一个错误，搜索引擎上没有找到相关的信息，有的人做了相关的记录来提示后来人：执行单文件存在引用时会报错。
这可能也是使用 golang 做测试的弊端，因为发展时间不长，没有像 Python 或者 Java 那样成熟的社区；废话不多说，我们一起来看看这个问题为什么会发生。
根本原因 其实从看看上面的这段提示：build failed，构建失败，我们应该就能看出一下信息。go test 与其他的指定源码文件进行编译或运行的命令程序一样（参考：go run和go build），会为指定的源码文件生成一个虚拟代码包——“command-line-arguments”，对于运行这次测试的命令程序来说，测试源码文件getinfo_test.go是属于代码包“command-line-arguments”的，可是它引用了其他包中的数据并不属于代码包“command-line-arguments”，编译不通过，错误自然发生了。
解决方法 解决 知道了原因之后，解决的方法就出来了，执行命令时加入这个测试文件需要引用的源码文件，在命令行后方的文件都会被加载到command-line-arguments中进行编译。。示例如下：
bingo@Mac Interface_test$ go test -v getinfo_test.go lib.go ok command-line-arguments 0.</description></item><item><title>浅谈GoMod</title><link>https://ruixi.me/p/%E6%B5%85%E8%B0%88gomod/</link><pubDate>Sun, 28 Nov 2021 16:24:57 +0800</pubDate><guid>https://ruixi.me/p/%E6%B5%85%E8%B0%88gomod/</guid><description>如果使用之前的GOPATH进行包管理的话会面临以下问题:
在不使用额外的工具的情况下，Go 的依赖包需要手工下载 第三方包没有版本的概念，如果第三方包的作者做了不兼容升级，会让开发者很难受 协作开发时，需要统一各个开发成员本地$GOPATH/src下的依赖包 引用的包引用了已经转移的包，而作者没改的话，需要自己修改引用 第三方包和自己的包的源码都在 src 下，很混乱。对于混合技术栈的项目来说，目录的存放会有一些问题 新的包管理模式go mod解决了以上问题:
自动下载依赖包(有前提) 项目不必放在 GOPATH/src 内了 项目内会生成一个 go.mod 文件，列出包依赖 所有来的第三方包会准确的指定版本号 对于已经转移的包，可以用 replace 申明替换，不需要改代码 准备工作 1.golang 版本必须支持 go mod
2.添加环境变量 GO111MODULE 为 on 或者auto
创建一个项目 首先，在$GOPATH/src 路径外的你喜欢的地方创建一个目录，cd 进入目录，新建一个 hello.go 文件，内容如下
package main import ( &amp;#34;fmt&amp;#34; ) func main() { fmt.Println(&amp;#34;Hello, world!&amp;#34;) } 初始化模块 在当前目录下，命令行运行 go mod init + 模块名称 初始化模块
go mod init hello 运行完后，会在当前项目目录下生成一个 go.mod 文件，这是一个关键文件，之后的包的管理都是通过这个文件管理。
官方说明：除了 go.</description></item><item><title>回车 &amp; 换行</title><link>https://ruixi.me/p/%E5%9B%9E%E8%BD%A6-%E6%8D%A2%E8%A1%8C/</link><pubDate>Sun, 28 Nov 2021 16:12:56 +0800</pubDate><guid>https://ruixi.me/p/%E5%9B%9E%E8%BD%A6-%E6%8D%A2%E8%A1%8C/</guid><description>关于“回车”（carriage return）和“换行”（line feed）这两个概念的来历和区别 关于换行和回车其实平时我们不太在意，所以关于两者的区别也不太清楚，在平时开发时可能会遇到一些文件处理的问题，放到不同的操作系统上出现各种坑。那么回车和换行到底有哪些区别呢？今天咱们就来总结一下。
1. 由来 在计算机还没有出现之前，有一种叫做电传打字机（Teletype Model 33）的机械打字机，每秒钟可以打10个字符。但是它有一个问题，就是打完一行换行的时候，要用去0.2秒，正好可以打两个字符。要是在这0.2秒里面，又有新的字符传过来，那么这个字符将丢失。
于是，研制人员想了个办法解决这个问题，就是在每行后面加两个表示结束的字符。一个叫做“回车”，告诉打字机把打印头定位在左边界，不卷动滚筒；另一个叫做“换行”，告诉打字机把滚筒卷一格，不改变水平位置。
这就是“换行”和“回车”的由来。
2. 使用 后来，计算机发明了，这两个概念也就被般到了计算机上。那时，存储器很贵，一些科学家认为在每行结尾加两个字符太浪费了，加一个就可以。于是，就出现了分歧。
回车 \r 本义是光标重新回到本行开头，r的英文return，控制字符可以写成CR，即Carriage Return
换行 \n 本义是光标往下一行（不一定到下一行行首），n的英文newline，控制字符可以写成LF，即Line Feed
符号 ASCII码 意义
\n 10 换行NL
\r 13 回车CR
在不同的操作系统这几个字符表现不同，比如在WIN系统下，这两个字符就是表现的本义，在UNIX类系统，换行\n就表现为光标下一行并回到行首，在MAC上，\r就表现为回到本行开头并往下一行，至于ENTER键的定义是与操作系统有关的。通常用的Enter是两个加起来。
不同操作系统下的含义：
\n: UNIX 系统行末结束符
\n\r: window 系统行末结束符
\r: MAC OS 系统行末结束符
我们经常遇到的一个问题就是，Unix/Mac系统下的文件在Windows里打开的话，所有文字会变成一行；而Windows里的文件在Unix/Mac下打开的话，在每行的结尾可能会多出一个^M符号。
3. 软回车和硬回车 再扩展一下回车的一些知识。
硬回车就是普通我们按回车产生的，它在换行的同时也起着段落分隔的作用。 软回车是用 Shift + Enter 产生的，它换行，但是并不换段，即前后两段文字在 Word 中属于同一“段”。在应用格式时你会体会到这一点。
软回车能使前后两行的行间距大幅度缩小，因为它不是段落标记，要和法定的段落标记——硬回车区别出来。硬回车的html代码是&amp;lt;p&amp;gt;..&amp;lt;/p&amp;gt;，段落的内容就夹在里面，而软回车的代码很精悍：&amp;lt;br&amp;gt;。网页的文字如果复制到word中，则硬回车变为弯曲的箭头，软回车变为向下的箭头。
转载在自:https://www.pythontab.com/html/2017/linuxkaiyuan_0115/1116.html</description></item><item><title>Animate_2021呆唯生日祭——说不完的省略号</title><link>https://ruixi.me/p/animate_2021%E5%91%86%E5%94%AF%E7%94%9F%E6%97%A5%E7%A5%AD%E8%AF%B4%E4%B8%8D%E5%AE%8C%E7%9A%84%E7%9C%81%E7%95%A5%E5%8F%B7/</link><pubDate>Sat, 27 Nov 2021 21:49:15 +0800</pubDate><guid>https://ruixi.me/p/animate_2021%E5%91%86%E5%94%AF%E7%94%9F%E6%97%A5%E7%A5%AD%E8%AF%B4%E4%B8%8D%E5%AE%8C%E7%9A%84%E7%9C%81%E7%95%A5%E5%8F%B7/</guid><description/></item><item><title>Go Run ,Go Build , Go Install</title><link>https://ruixi.me/p/go-run-go-build-go-install/</link><pubDate>Fri, 26 Nov 2021 07:47:36 +0800</pubDate><guid>https://ruixi.me/p/go-run-go-build-go-install/</guid><description>在实际操作之前，我们需要知道 go 有三种源码文件：
1，命令源码文件；声明自己属于 main 包，并且包含 main 函数的文件，每个项目只能有一个这样的文件，即程序的入口文件
2，库源码文件；不能直接被执行的源码文件
3，测试源码文件
go run : 编译并直接运行程序，不产生可执行文件，只产生临时文件，方便用户调试（即在 bin 目录和 pkg 目录不产生任何文件）,其后只能+命令源码文件。
go build : 既可以+库源码文件，又可以+命令源码文件,主要功能是检查是否有编译错误
+库源码文件：只是检查编译错误，不产生任何文件,如果库源码文件有语法错误，编译不通过会报错。
+命令源码文件：产生一个可执行文件
go install : 执行的过程：编译库源码文件-&amp;gt;编译命令源码文件-&amp;gt;移动编译文件，命令源码文件的编译后的二进制文件移到$GOPATH/bin目录下；库源码文件的编译移到$GOPATH/pkg 目录,后缀名为.a 的文件。这个移动目录的过程称为安装。
Ps：上述的二进制可执行文件可独立运行，当然可以放在任何目录下运行啦</description></item><item><title>Video</title><link>https://ruixi.me/p/video/</link><pubDate>Thu, 25 Nov 2021 16:02:33 +0800</pubDate><guid>https://ruixi.me/p/video/</guid><description/></item></channel></rss>