<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Ruixi-rebirth</title><link>https://ruixi.me/tags/go/</link><description>Recent content in Go on Ruixi-rebirth</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 28 Nov 2021 17:09:23 +0800</lastBuildDate><atom:link href="https://ruixi.me/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>解决go test对单个文件进行单元测试提示undefiend</title><link>https://ruixi.me/p/%E8%A7%A3%E5%86%B3go-test%E5%AF%B9%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8F%90%E7%A4%BAundefiend/</link><pubDate>Sun, 28 Nov 2021 17:09:23 +0800</pubDate><guid>https://ruixi.me/p/%E8%A7%A3%E5%86%B3go-test%E5%AF%B9%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8F%90%E7%A4%BAundefiend/</guid><description>&lt;img src="https://ruixi.me/p/%E8%A7%A3%E5%86%B3go-test%E5%AF%B9%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8F%90%E7%A4%BAundefiend/feature.png" alt="Featured image of post 解决go test对单个文件进行单元测试提示undefiend" />&lt;p>&lt;em>&lt;strong>我的报错截图:&lt;/strong>&lt;/em>&lt;/p>
&lt;p>&lt;img src="https://ruixi.me/p/%E8%A7%A3%E5%86%B3go-test%E5%AF%B9%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8F%90%E7%A4%BAundefiend/error.jpg"
width="850"
height="624"
srcset="https://ruixi.me/p/%E8%A7%A3%E5%86%B3go-test%E5%AF%B9%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8F%90%E7%A4%BAundefiend/error_hue036e71731a728d226cddfaab0bfae22_85845_480x0_resize_q75_box.jpg 480w, https://ruixi.me/p/%E8%A7%A3%E5%86%B3go-test%E5%AF%B9%E5%8D%95%E4%B8%AA%E6%96%87%E4%BB%B6%E8%BF%9B%E8%A1%8C%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E6%8F%90%E7%A4%BAundefiend/error_hue036e71731a728d226cddfaab0bfae22_85845_1024x0_resize_q75_box.jpg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="136"
data-flex-basis="326px"
>&lt;/p>
&lt;h2 id="具体解决方案">具体解决方案&lt;/h2>
&lt;p>很多人记录过怎么执行 go test 单个文件或者单个函数，但是要么对执行单文件用例存在函数或变量引用的场景避而不谈，要么提示调用了其它文件中的模块会报错。其实了解了 golang 命令程序的机制之后，这个问题就迎刃而解了。&lt;/p>
&lt;h1 id="阅读目录">&lt;strong>阅读目录&lt;/strong>&lt;/h1>
&lt;ul>
&lt;li>&lt;a class="link" href="#_label0" >背景&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#_label1" >根本原因&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#_label2" >解决方法&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="#_label3" >总结&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="背景">背景&lt;/h2>
&lt;p>很多人记录过怎么执行 go test 单个文件或者单个函数，但是要么对执行单文件用例存在函数或变量引用的场景避而不谈，要么提示调用了其它文件中的模块会报错。其实了解了 go test 命令的机制之后，这个问题就迎刃而解了。&lt;/p>
&lt;p>也是一个同事向我求助我才知道有这样一个问题存在，因为场景特殊他只想执行我们的测试代码其中一个文件中的测试代码，因为调用的信息都在同一目录（package）下，原代码执行是不存在引用问题的，直接执行&lt;code>go test&lt;/code>也是可以运行的，但是单独运行其中一个文件时，出现了下面的错误：&lt;/p>
&lt;pre>&lt;code>bingo@Mac Interface_test$ go test -v getinfo_test.go
# command-line-arguments
./getinfo_test.go:34:23: undefined: touch
./getinfo_test.go:35:23: undefined: verify
...
FAIL command-line-arguments [build failed]
&lt;/code>&lt;/pre>
&lt;p>这也许是很多数人会遇到的一个错误，搜索引擎上没有找到相关的信息，有的人做了相关的记录来提示后来人：执行单文件存在引用时会报错。&lt;/p>
&lt;p>这可能也是使用 golang 做测试的弊端，因为发展时间不长，没有像 Python 或者 Java 那样成熟的社区；废话不多说，我们一起来看看这个问题为什么会发生。&lt;/p>
&lt;h2 id="根本原因">根本原因&lt;/h2>
&lt;p>其实从看看上面的这段提示：&lt;code>build failed&lt;/code>，构建失败，我们应该就能看出一下信息。go test 与其他的指定源码文件进行编译或运行的命令程序一样（参考：&lt;code>go run&lt;/code>和&lt;code>go build&lt;/code>），会为指定的源码文件生成一个虚拟代码包——“command-line-arguments”，对于运行这次测试的命令程序来说，测试源码文件&lt;code>getinfo_test.go&lt;/code>是属于代码包“command-line-arguments”的，可是它引用了其他包中的数据并不属于代码包“command-line-arguments”，编译不通过，错误自然发生了。&lt;/p>
&lt;h2 id="解决方法">解决方法&lt;/h2>
&lt;h3 id="解决">解决&lt;/h3>
&lt;p>知道了原因之后，解决的方法就出来了，&lt;strong>执行命令时加入这个测试文件需要引用的源码文件&lt;/strong>，&lt;strong>在命令行后方的文件都会被加载到&lt;code>command-line-arguments&lt;/code>中进行编译。&lt;/strong>。示例如下：&lt;/p>
&lt;pre>&lt;code>bingo@Mac Interface_test$ go test -v getinfo_test.go lib.go
ok command-line-arguments 0.008s
&lt;/code>&lt;/pre>
&lt;h3 id="多级引用或多个引用包的情况">多级引用或多个引用包的情况&lt;/h3>
&lt;p>如果对多个包存在引用关系，或者引用的包对当前目录的其他文件存在引用，也都是一样的方法，把他们加在命令后方即可。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>测试单个文件，一定要带上被测试的原文件，如果原文件有其他引用，也需一并带上。&lt;/p>
&lt;p>(文章转载自&lt;a class="link" href="https://www.cnblogs.com/Detector/p/10010292.html" target="_blank" rel="noopener"
>https://www.cnblogs.com/Detector/p/10010292.html&lt;/a>)&lt;/p></description></item><item><title>浅谈GoMod</title><link>https://ruixi.me/p/%E6%B5%85%E8%B0%88gomod/</link><pubDate>Sun, 28 Nov 2021 16:24:57 +0800</pubDate><guid>https://ruixi.me/p/%E6%B5%85%E8%B0%88gomod/</guid><description>&lt;img src="https://ruixi.me/p/%E6%B5%85%E8%B0%88gomod/feature.png" alt="Featured image of post 浅谈GoMod" />&lt;p>如果使用之前的&lt;strong>GOPATH&lt;/strong>进行包管理的话会面临以下问题:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>在不使用额外的工具的情况下，Go 的依赖包需要手工下载&lt;/strong>&lt;/li>
&lt;li>&lt;strong>第三方包没有版本的概念，如果第三方包的作者做了不兼容升级，会让开发者很难受&lt;/strong>&lt;/li>
&lt;li>&lt;strong>协作开发时，需要统一各个开发成员本地&lt;code>$GOPATH/src&lt;/code>下的依赖包&lt;/strong>&lt;/li>
&lt;li>&lt;strong>引用的包引用了已经转移的包，而作者没改的话，需要自己修改引用&lt;/strong>&lt;/li>
&lt;li>&lt;strong>第三方包和自己的包的源码都在 src 下，很混乱。对于混合技术栈的项目来说，目录的存放会有一些问题&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>新的包管理模式&lt;strong>go mod&lt;/strong>解决了以上问题:&lt;/p>
&lt;ul>
&lt;li>&lt;strong>自动下载依赖包(有前提)&lt;/strong>&lt;/li>
&lt;li>&lt;strong>项目不必放在 GOPATH/src 内了&lt;/strong>&lt;/li>
&lt;li>&lt;strong>项目内会生成一个 go.mod 文件，列出包依赖&lt;/strong>&lt;/li>
&lt;li>&lt;strong>所有来的第三方包会准确的指定版本号&lt;/strong>&lt;/li>
&lt;li>&lt;strong>对于已经转移的包，可以用 replace 申明替换，不需要改代码&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="准备工作">准备工作&lt;/h2>
&lt;p>1.golang 版本必须支持 go mod&lt;/p>
&lt;p>2.添加环境变量  &lt;strong>GO111MODULE&lt;/strong>  为  &lt;strong>on&lt;/strong>  或者&lt;strong>auto&lt;/strong>&lt;/p>
&lt;h2 id="创建一个项目">创建一个项目&lt;/h2>
&lt;p>首先，在$GOPATH/src 路径外的你喜欢的地方创建一个目录，cd 进入目录，新建一个 hello.go 文件，内容如下&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">import&lt;/span> &lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="s">&amp;#34;fmt&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">fmt&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Println&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s">&amp;#34;Hello, world!&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="初始化模块">初始化模块&lt;/h2>
&lt;p>在当前目录下，命令行运行 go mod init + 模块名称 初始化模块&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="nx">mod&lt;/span> &lt;span class="nx">init&lt;/span> &lt;span class="nx">hello&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>运行完后，会在当前项目目录下生成一个 go.mod 文件，这是一个关键文件，之后的包的管理都是通过这个文件管理。&lt;/p>
&lt;blockquote>
&lt;p>官方说明：除了 go.mod 之外，go 命令还维护一个名为 go.sum 的文件，其中包含特定模块版本内容的预期加密哈希&lt;br>
go 命令使用 go.sum 文件确保这些模块的未来下载检索与第一次下载相同的位，以确保项目所依赖的模块不会出现意外更改，无论是出于恶意、意外还是其他原因。 go.mod 和 go.sum 都应检入版本控制。&lt;br>
go.sum 不需要手工维护，所以可以不用太关注。&lt;/p>
&lt;/blockquote>
&lt;p>生成出来的文件包含模块名称和当前的 go 版本号&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">module&lt;/span> &lt;span class="nx">hello&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">go&lt;/span> &lt;span class="mf">1.17&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>注意&lt;/strong>：子目录里是不需要 init 的，所有的子目录里的依赖都会组织在根目录的 go.mod 文件里&lt;/p>
&lt;h2 id="看看-go-mod-如何工作的">看看 go mod 如何工作的&lt;/h2>
&lt;p>接下来，让项目依赖一下第三方包以大部分人都熟悉的 beego 为例吧！修改 Hello.go 文件：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre tabindex="0" class="chroma">&lt;code class="language-golang" data-lang="golang">&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">package&lt;/span> &lt;span class="nx">main&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kn">import&lt;/span> &lt;span class="s">&amp;#34;github.com/astaxie/beego&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">main&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="p">{&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nx">beego&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nf">Run&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来执行 go run hello.go 然后会提示叫用 go get 下载引用第三方包，那就用呗。&lt;/p>
&lt;p>下载完第三方包后，再次 go run hello.go 就跑起来啦！&lt;/p>
&lt;h2 id="问题依赖的包下载到哪里了">问题：依赖的包下载到哪里了？&lt;/h2>
&lt;p>使用 Go 的包管理方式，依赖的第三方包被下载到了$GOPATH/pkg/mod 路径下。（可以自行更改下载路径）&lt;/p></description></item><item><title>Go Run ,Go Build , Go Install</title><link>https://ruixi.me/p/go-run-go-build-go-install/</link><pubDate>Fri, 26 Nov 2021 07:47:36 +0800</pubDate><guid>https://ruixi.me/p/go-run-go-build-go-install/</guid><description>&lt;img src="https://ruixi.me/p/go-run-go-build-go-install/go.jpg" alt="Featured image of post Go Run ,Go Build , Go Install" />&lt;p>在实际操作之前，我们需要知道 go 有三种源码文件：&lt;/p>
&lt;p>1，命令源码文件；声明自己属于 main 包，并且包含 main 函数的文件，每个项目只能有一个这样的文件，即程序的入口文件&lt;/p>
&lt;p>2，库源码文件；不能直接被执行的源码文件&lt;/p>
&lt;p>3，测试源码文件&lt;/p>
&lt;p>go run : 编译并直接运行程序，不产生可执行文件，只产生临时文件，方便用户调试（即在 bin 目录和 pkg 目录不产生任何文件）,其后只能+命令源码文件。&lt;/p>
&lt;p>go build : 既可以+库源码文件，又可以+命令源码文件,主要功能是检查是否有编译错误&lt;/p>
&lt;p>+库源码文件：只是检查编译错误，不产生任何文件,如果库源码文件有语法错误，编译不通过会报错。&lt;/p>
&lt;p>+命令源码文件：产生一个可执行文件&lt;/p>
&lt;p>go install : 执行的过程：编译库源码文件-&amp;gt;编译命令源码文件-&amp;gt;移动编译文件，命令源码文件的编译后的二进制文件移到$GOPATH/bin目录下；库源码文件的编译移到$GOPATH/pkg 目录,后缀名为.a 的文件。这个移动目录的过程称为安装。&lt;/p>
&lt;p>Ps：上述的二进制可执行文件可独立运行，当然可以放在任何目录下运行啦&lt;/p></description></item></channel></rss>